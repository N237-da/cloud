# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-java-with-maven

# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.
name: Java CI/CD Pipeline

on:
  push:
    branches: ["main"]

env:
  APP_NAME: cdsir_backend
  NAMESPACE: app
  PORT: 8081
  CLUSTER_NAME: kind  # Nom explicite du cluster

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: temurin
          cache: maven

      - name: Build application
        run: |
          chmod +x mvnw
          ./mvnw clean package -DskipTests

  docker:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.APP_NAME }}:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.APP_NAME }}:${{ github.sha }}

  deploy:
    runs-on: ubuntu-latest
    needs: docker
    steps:
      - uses: actions/checkout@v4

      # 1. Créer le cluster KinD AVEC un nom explicite
      - name: Create KinD cluster
        uses: helm/kind-action@v1.8.0
        with:
          cluster_name: ${{ env.CLUSTER_NAME }}
          config: |
            kind: Cluster
            apiVersion: kind.x-k8s.io/v1alpha4
            name: ${{ env.CLUSTER_NAME }}
            nodes:
            - role: control-plane

      # 2. Configurer kubectl
      - name: Set up kubectl
        uses: azure/setup-kubectl@v4

      # 3. Vérifier le cluster
      - name: Verify cluster
        run: |
          kubectl config use-context kind-${{ env.CLUSTER_NAME }}
          kubectl cluster-info
          kubectl get nodes

      # 4. Charger l'image dans KinD - CORRECTION ICI
      - name: Load Docker image to KinD
        run: |
          # Télécharger l'image
          docker pull ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.APP_NAME }}:latest
          
          # Charger dans KinD avec le bon nom de cluster
          kind load docker-image \
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.APP_NAME }}:latest \
            --name ${{ env.CLUSTER_NAME }}
          
          # Vérifier que l'image est chargée
          echo "Images dans le cluster:"
          docker exec ${{ env.CLUSTER_NAME }}-control-plane crictl images | grep ${{ env.APP_NAME }}

      # 5. Déployer l'application
      - name: Deploy application
        run: |
          # Appliquer le namespace
          kubectl apply -f k8s/namespace.yaml
          
          # Créer un deployment avec la bonne image
          cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: cloud-pro
            namespace: ${{ env.NAMESPACE }}
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: backend
            template:
              metadata:
                labels:
                  app: backend
              spec:
                containers:
                - name: backend
                  image: ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.APP_NAME }}:latest
                  imagePullPolicy: IfNotPresent
                  ports:
                  - containerPort: ${{ env.PORT }}
          EOF
          
          # Appliquer le service
          kubectl apply -f k8s/service.yaml
          
          # Vérifier
          echo "=== État du déploiement ==="
          kubectl get all -n ${{ env.NAMESPACE }}

      # 6. Attendre que le pod soit prêt
      - name: Wait for pods
        run: |
          echo "Attente du démarrage du pod..."
          for i in {1..30}; do
            if kubectl get pods -n ${{ env.NAMESPACE }} -l app=backend -o jsonpath='{.items[*].status.phase}' | grep -q Running; then
              echo "✓ Pod en cours d'exécution"
              break
            fi
            echo "En attente... ($i/30)"
            sleep 5
          done
          
          kubectl get pods -n ${{ env.NAMESPACE }}

      # 7. Vérifier les logs
      - name: Check logs
        run: |
          echo "=== Logs de démarrage ==="
          kubectl logs -n ${{ env.NAMESPACE }} -l app=backend --tail=20
